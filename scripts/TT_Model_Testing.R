library(rjags)
library(coda)
library(dplyr)
library(tidyr)
library(rnpn)

# Read in output of previous script
dat.b <- read.csv("../data_processed/Oak_collection_budburst.csv")
dat.b$Accession <- unlist(lapply(strsplit(paste(dat.b$PlantNumber), "-"), function(x){x[1]}))
dat.b$Date <- as.Date(dat.b$Date)


# Read in output of previous script
dat.l <- read.csv("../data_processed/Oak_collection_leaf.csv")
dat.l$Accession <- unlist(lapply(strsplit(paste(dat.l$PlantNumber), "-"), function(x){x[1]}))
dat.l$Date <- as.Date(dat.l$Date)

met.all <- read.csv("../data_processed/Arb_Pheno/Daymet_clean_data.csv")
met.all$TMEAN <- (met.all$tmax..deg.c. + met.all$tmin..deg.c.)/2

#Pulling out the number of observations we have for each species
SP.burst <- as.data.frame(table(dat.b[, "Species"]))
colnames(SP.burst) <- c("Species", "Freq")

#Pulling out the number of observations we have for each species
SP.leaf <- as.data.frame(table(dat.l[, "Species"]))
colnames(SP.leaf) <- c("Species", "Freq")

#CHecking which species we don't have budburst information for
setdiff(SP.leaf$Species, SP.burst$Species)

#SP.burst <- SP.burst[(1:5),]

#Creating a data frame to check the model output
Check <- data.frame()
l <- 1

SP.burst <- SP.burst[1:3,]

for(SP in SP.burst$Species){
  
Check[l, "species"] <- SP
Check[l, "burst.nObs"] <- SP.burst[SP.burst$Species == SP, "Freq"]
dat.burst <- dat.b[dat.b$Species == SP, ]

burst.ind <- aggregate(Accession~PlantNumber, data=dat.burst,
                       FUN=min)

burst.acc <- aggregate(Species~Accession, data=dat.burst,
                       FUN=min)

hierarchical_regression <- "
  model{
  for(k in 1:n){
    sum[1, k] <- 0 #Initializing our cumulative value to play nice
    for(j in 1:365){
      GDD[j, k] <- ifelse(met[j,k]>Tbase, met[j,k]-Tbase, 0) #Standard GDD calculation line
      
      GDD.day[j, k] <- ifelse(GDD[j, k] + sum[j, k] >= ind[pln[k]], -999, j-1) #Any day before the Threshold becomes 999                                                               #Any day after the Threshold becomes yday-1 (-1 because of the way the sum works)
    
      sum[j+1, k] <- GDD[j, k] + sum[j, k] #Creating the cumulative value to build over time. Actually 1 day ahead so we take j-1
    }
    mu[k] <- max(GDD.day[,k]) #Earliest day that passes the Threshold
    y[k] ~ dnorm(mu[k], sPrec) # Normalized by our observation uncertainty
  }
    
    for(j in 1:nSp){
      THRESH[j] <-  a[j]
      a[j] ~ dnorm(Tprior[j], aPrec[j])
      aPrec[j] ~ dgamma(0.1, 0.1)
      Tprior[j] ~ dunif(0, 1000)
    }

    for(t in 1:nAcc){
      Accession[t] <-  THRESH[sp[t]] + b[t]
      b[t] ~ dnorm(0, bPrec[t])
      bPrec[t] ~ dgamma(0.1, 0.1)
    }
    
    for(i in 1:nPln){
        ind[i] <-  Accession[acc[i]] + c[i]
        c[i] ~ dnorm(0, cPrec)
    }
    
    sPrec ~ dgamma(0.1, 0.1)
    cPrec ~ dgamma(0.1, 0.1)
    Tbase ~ dunif(-5, 15)

  }
  "

burst.list <- list(y = dat.burst$Yday, n = length(dat.burst$Yday), yr = dat.burst$Year,
                   pln = as.numeric(factor(dat.burst$PlantNumber)), nPln = length(unique(dat.burst$PlantNumber)),
                   acc = as.numeric(factor(burst.ind$Accession)), nAcc = length(unique(dat.burst$Accession)),
                   sp = as.numeric(factor(burst.acc$Species)), nSp = length(unique(dat.burst$Species)))

burst.list$met <- matrix(nrow=365, ncol=length(burst.list$yr))


#for(i in 1:length(burst.list$yr)){
#  burst.list$met[,i] <- (met.all[met.all$year == burst.list$yr[i], "TMEAN"])
#}

done <- data.frame(nrow=365)
for(i in 1:length(burst.list$yr)){
 met <- (met.all[met.all$year == burst.list$yr[i], "TMEAN"])
 done <- cbind(done, met)
}

done <- subset(done, select = -c(1))
colnames(done) <- c(dat.burst$Year)
  
burst.list$met <- done
#Setting the number of MCMC chains and their parameters
nchain = 3
inits <- list()
for(i in 1:nchain){
  inits[[i]] <- list(  #Added length equal to number of species
    Fcrit = runif(1,100,200),
    Tbase = runif(1,2,7))
}

#---------------------------------------------------------#
#This section actually runs the model and then provides ways to check the output and clean it
#---------------------------------------------------------#
burst.model   <- jags.model (file = textConnection(hierarchical_regression),
                             data = burst.list,
                             n.chains = 3)

#Converting the ooutput into a workable format
burst.out   <- coda.samples (model = burst.model,
                             variable.names = c("Tprior", "aPrec", "Tbase"),
                             n.iter = 50000)

gelman.diag(burst.out)

bud.con <- gelman.diag(burst.out)
Check[l, "burst.Tbase.converge"] <- bud.con[[1]][1]
Check[l, "burst.Thresh.converge"] <- bud.con[[1]][2]

burnin = 40000                                ## determine convergence from GBR output
burst.burn <- window(burst.out,start=burnin)  ## remove burn-in
summary(burst.burn)

burst.df <- as.data.frame(as.matrix(burst.burn))

burst.df$sd <- 1/sqrt(burst.df[,"aPrec"])
summary(burst.df)

bud.density <- as.data.frame(apply(as.matrix(burst.df), 1 , function(x) rnorm(1, mean=as.numeric(x[2]), sd=as.numeric(x[4]))))
burst.df$species <- SP
bud.ci <- apply(as.matrix(bud.density),2,quantile,c(0.025,0.5,0.975))

Check[l, "burst 2.5%"] <- bud.ci[1]
Check[l, "burst 50%"] <- bud.ci[2]
Check[l, "burst 97.5%"] <- bud.ci[3]

#write.csv(burst.df, file.path("../data_processed/Arb_Pheno", paste0(SP, "NewTT_model_budburst.csv")), row.names=F)

l <- l + 1
}

Check
Tbase <- 5
Fcrit <- 180

for(k in 1:length(burst.list$yr)){
  GDD <- ifelse(burst.list$met[1]>Tbase, burst.list$met-Tbase, 0)
  mu <- which(cumsum(GDD) >= Fcrit)[1]
  y[k] ~ dnorm(mu[k], sPrec)
}

GDD.cum <- matrix(nrow=365, ncol=length(burst.list$yr))
for(k in 1:n){
  for(j in 1:365){
    GDD[j] <- burst.list$met[j,k]-Tbase
    GDD[j[GDD[j] < 0]] <-  0
    GDD.cum[j, k] <- GDD[j]
  }
  mu[k] <- (which(cumsum(GDD.cum[,k]) >= Fcrit))[1]
}

cum <- matrix(nrow=366, ncol=length(burst.list$yr))
test <- matrix(nrow=365, ncol=length(burst.list$yr))

for(k in 1:n){
  cum[1, k] <- 0
  for(j in 1:365){
    GDD[j, k] <- ifelse(met[j,k]>Tbase, met[j,k]-Tbase, 0)
    GDD.cum[j, k] <- ifelse(GDD[j, k] + cum[j, k] <= Fcrit, 999, j)
    cum[j+1, k] <- GDD[j, k] + cum[j, k]
  }
  mu[k] <- min(GDD.cum[,k])
}
            
